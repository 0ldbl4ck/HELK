# HELK Network Fingerprints
# HELK build Stage: Alpha
# Author: Nate Guagenti (@neu5ron)
# License: GPL-3.0

filter {
  # Because other versions of network community ID are already renamed to HELK naming, check to make sure this field does NOT already exist
  if ![fingerprint_network_community_id] {
    # Lookup community id event's containing network parameters
    if [src_ip_addr] and [dst_ip_addr] and [network_protocol] and [dst_port] and [src_port] and [@metadata][src_ip_addr][number_of_ip_addresses] == 1 and [@metadata][dst_ip_addr][number_of_ip_addresses] == 1 {
      ruby {
        path => "/usr/share/logstash/pipeline/ruby/community-id.rb"
        script_params => {
          "source_ip_field" => "src_ip_addr"
          "dest_ip_field" => "dst_ip_addr"
          "source_port_field" => "src_port"
          "dest_port_field" => "dst_port"
          "protocol_field" => "network_protocol"
          "target_field" => "fingerprint_network_community_id"
        }
        add_field => { "etl_pipeline" => "community_id_addition" }
        tag_on_exception =>  "_rubyexception-community_id"
      }
    }
  }
  
  # Anything containing src ip address
  if [src_ip_addr] {
    # Only continue if src_ip_addr is not an array
    if [@metadata][src_ip_addr][number_of_ip_addresses] == 1 {
      # Check if dst ip exists
      if [dst_ip_addr] {

        # Use this so don't have to always do a duplicate check later on, save some cycles for the CPU :)
        # Don't ask why doing this and instead of using concatenate below..... because CONCATENATE SORTS.. AND EVEN SORTS when using a string.....WTHeck?!
        mutate {
          add_field => {
            "[@metadata][dst_and_src_ip_addr_concat]" => "%{dst_ip_addr}%{src_ip_addr}"
            "[@metadata][src_and_dst_ip_addr_concat]" => "%{src_ip_addr}%{dst_ip_addr}"
            "etl_pipeline" => "concatanate-src_and_dst_ip_addrs"
          }
        }

        # Fingerprint dst and src ip pair
        fingerprint {
          source => [ "[@metadata][dst_and_src_ip_addr_concat]" ]
          concatenate_sources => false
          method => "MURMUR3"
          target => "fingerprint_ip_addr_pair_dst_and_src"
          add_field => { "etl_pipeline" => "fingerprint-ip_addr_pair_dst_and_src" }
        }

        # Fingerprint src and dst ip pair
        fingerprint {
          source => [ "[@metadata][src_and_dst_ip_addr_concat]" ]
          concatenate_sources => false
          method => "MURMUR3"
          target => "fingerprint_ip_addr_pair_src_and_dst"
          add_field => { "etl_pipeline" => "fingerprint-ip_addr_pair_src_and_dst" }
        }

        # In order to do a true any ip pair field, we need to sort the two hashes above, and then fingerprint
        # also lets determine if src ip is the same as dst ip
        ruby {
          code => "
            # Get the two hashes above
            ip_dst_n_src_pair = event.get('fingerprint_ip_addr_pair_dst_and_src')
            ip_src_n_dst_pair = event.get('fingerprint_ip_addr_pair_src_and_dst')
            # See if src equals dst
            src_same_as_dst = ip_dst_n_src_pair === ip_src_n_dst_pair
            # Make an array for sorting then joining
            ip_pair_array = [ ip_dst_n_src_pair, ip_src_n_dst_pair ]
            ip_pair_any = ip_pair_array.sort.join('')
            event.set('fingerprint_ip_addr_any_dst_and_src', ip_pair_any)
            event.set('meta_src_ip_addr_equals_dst_ip_addr', src_same_as_dst)
          "
          tag_on_exception =>  "_rubyexception-fingerprint-ip_addr_any_dst_and_src"
          add_field => { "etl_pipeline" => "fingerprint-ip_addr_any_dst_and_src" }
        }

        # Check if src port exists
        if [src_port] {
          # Check if dst port exists
          if [dst_port] {

            # Fingerprint the network 4 tuple
            # But lets use the "fingerprint_ip_addr_pair_src_and_dst" hash from above, so we don't have to rehash 2 things already hashed, save some cycles for the CPU :)
            fingerprint {
              source => [ "fingerprint_ip_addr_pair_src_and_dst", "dst_port", "network_protocol" ]
              concatenate_sources => true
              method => "MURMUR3"
              target => "fingerprint_network_4tuple"
              add_field => { "etl_pipeline" => "fingerprint-network_4tuple" }
            }

            # Check if network_protocol exists
            #if [network_protocol] {
            #
            #  # Fingperint the network 5 tuple
            #  # But lets use the "fingerprint_network_4tuple" hash from above, so we don't have to rehash 4 things already hashed, save some cycles for the CPU :)
            #  fingerprint {
            #    source => [ "fingerprint_network_4tuple", "src_port" ]
            #    concatenate_sources => true
            #    method => "MURMUR3"
            #    target => "fingerprint_network_4tuple"
            #    add_field => { "etl_pipeline" => "fingerprint-network_5tuple" }
            #  }
            #}

          }
        }
      }
    }
  }
  
}